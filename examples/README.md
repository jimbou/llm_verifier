
## Example of verifier use : Prime Checker Function 

This section provides a detailed example of using the llm verifier to autocomplete the prime check function. The example includes code snippets, prompts, and responses from the language model, along with the reports generated by KLEE and Infer static analysis tools.

### Code Snippet for Autocompletion

The initial code snippet provided for autocompletion is as follows:

```c
int is_prime(int n) {
    //find if the number is prime
    
}  
```
- The output requested was : true if the input number is prime, false if it is not
- The context given was : the inputs must be positive numbers , the output is a boolean. Maybe have some assertions for numbers we know as test cases

### Prompt Created

The prompt created for the language model was:

```c
/*Desired output: I want true if the input number is prime, false if it is not
*/
/*Relevant Context: the inputs must be positive numbers , the output is a boolean. Maybe have some assertions for numbers we know as test cases
*/


//start_function pls keep this comment in your response


int is_prime(int n) {
    //find if the number is prime
    

    //please fill the rest of the code

}
//end_function pls keep this comment in your response

//now pls create a main in the correct format to be analysed by klee

//start_main pls keep this comment in your response
int main(){
    //klee symbolics creation

    //necessary klee assumes

    
    // call the function with the symbolic parameters

    //necessary klee asserts
    return 0;
}
//end_main pls keep this comment in your response
```

### Response from the Language Model

The language model provided the following response:
```plaintext
Certainly, I can help you structure the `is_prime` function along with a main function designed to be analyzed by KLEE, a symbolic execution tool. KLEE works by taking specially prepared code, executing it symbolically, and using constraints derived from the code paths to determine truths about the program, such as potential bugs or in this case, to verify the correctness of the prime checking function.

### Prime Function
In the `is_prime` function, a prime number is only divisible by 1 and itself, so we need to check divisibility from 2 up to the square root of `n` (since any factor larger than the square root would have a corresponding factor smaller than the square root).

### KLEE Main Function
For the main function, we'll create a symbolic variable (let's call it `a`). KLEE will treat this variable as symbolic, meaning KLEE will consider all possible values that `a` can take on that satisfy the constraints we impose. We'll then add constraints (using `klee_assume`) to ensure `a` is a positive number, as prime checking only makes sense for positive integers. Finally, we'll assert our expectations (using `klee_assert`) about the output of `is_prime` for specific values of `a` we know are prime or not.

Here's how your code could look:

```c
//start_function pls keep this comment in your response

int is_prime(int n) {
    if (n <= 1) return 0; // 0 and 1 are not prime numbers
    if (n <= 3) return 1; // 2 and 3 are prime numbers
    
    // This is checked so that we can skip middle five numbers in below loop
    if (n % 2 == 0 || n % 3 == 0) return 0;
    
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return 0;
    }
    return 1;
}

//end_function pls keep this comment in your response

//start_main pls keep this comment in your response

#include <klee/klee.h>

int main() {
    int a;
    klee_make_symbolic(&a, sizeof(a), "a"); // klee symbolics creation

    klee_assume(a > 0); // necessary klee assumes, prime numbers are positive

    int result = is_prime(a); // call the function with the symbolic parameter

    // necessary klee asserts
    // Example assertions for known primes and non-primes for validation
    if (a == 2 || a == 3 || a == 5 || a == 7)
        klee_assert(result == 1); // Assert that the function recognizes known primes
    else if (a == 1 || a == 4 || a == 6 || a == 8 || a == 9)
        klee_assert(result == 0); // Assert that the function recognizes known non-primes

    return 0;
}

//end_main pls keep this comment in your response
```

In this setup, KLEE will explore various paths through the `is_prime` function, using both the assumptions and the assertions to guide and check its analysis. Remember, the effectiveness of this analysis greatly depends on the range of values KLEE considers for `a`, which is influenced by the constraints (`klee_assume`) you impose and the computational resources available for KLEE to use.
```
 ### Extracting the code for the analysis and creation of the files used for klee and infer analysis

#### The c source code analysed by infer  is
```c

int fibonacci(int n) {
    //check that the input is positive
    if (n < 0) {
        return -1;
    }

    //find the nth fibonacci number
    int f[n + 2]; // 0th and 1st number of the series are 0 and 1
    f[0] = 0;
    f[1] = 1;

    for (int i = 2; i <= n; i++) {
        // Add the previous 2 numbers in the series and store it
        f[i] = f[i - 1] + f[i - 2];
    }

    return f[n];
}
```


#### The c source code analysed by klee is
```c
#include <klee/klee.h>

int is_prime(int n) {
    if (n <= 1) return 0; // 0 and 1 are not prime numbers
    if (n <= 3) return 1; // 2 and 3 are prime numbers
    
    // This is checked so that we can skip middle five numbers in below loop
    if (n % 2 == 0 || n % 3 == 0) return 0;
    
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return 0;
    }
    return 1;
}

#include <klee/klee.h>

int main() {
    int a;
    klee_make_symbolic(&a, sizeof(a), "a"); // klee symbolics creation

    klee_assume(a > 0); // necessary klee assumes, prime numbers are positive

    int result = is_prime(a); // call the function with the symbolic parameter

    // necessary klee asserts
    // Example assertions for known primes and non-primes for validation
    if (a == 2 || a == 3 || a == 5 || a == 7)
        klee_assert(result == 1); // Assert that the function recognizes known primes
    else if (a == 1 || a == 4 || a == 6 || a == 8 || a == 9)
        klee_assert(result == 0); // Assert that the function recognizes known non-primes

    return 0;
}
```

### Analysis Reports

#### Infer Report

```
No issues found
```

#### KLEE Report

KLEE provided warnings but no errors:
```plaintext
[0;1;37mKLEE: NOTE: Using klee-uclibc : /tmp/klee_build130stp_z3/runtime/lib/klee-uclibc.bca
[0mKLEE: output directory is "/home/klee/verification/klee-out-0"
[0mKLEE: Using STP solver backend
[0mKLEE: SAT solver: MiniSat
[0mwarning: Linking two modules of different target triples: 'verification/klee_analysis.bc' is 'x86_64-unknown-linux-gnu' whereas '__uClibc_main.os' is 'x86_64-pc-linux-gnu'

warning: Linking two modules of different target triples: 'klee_div_zero_check64_Debug+Asserts.bc' is 'x86_64-unknown-linux-gnu' whereas '__uClibc_main.os' is 'x86_64-pc-linux-gnu'

warning: Linking two modules of different target triples: 'klee_overshift_check64_Debug+Asserts.bc' is 'x86_64-unknown-linux-gnu' whereas '__uClibc_main.os' is 'x86_64-pc-linux-gnu'

[0;35mKLEE: WARNING: undefined reference to function: __syscall_rt_sigaction
[0m[0;35mKLEE: WARNING: undefined reference to function: fcntl
[0m[0;35mKLEE: WARNING: undefined reference to function: fstat
[0m[0;35mKLEE: WARNING: undefined reference to function: ioctl
[0m[0;35mKLEE: WARNING: undefined reference to function: open
[0m[0;35mKLEE: WARNING: undefined reference to function: write
[0m[0;35mKLEE: WARNING: undefined reference to function: kill (UNSAFE)!
[0m[0;1;35mKLEE: WARNING ONCE: calling external: ioctl(0, 21505, 105537974608928) at libc/termios/tcgetattr.c:43 12
[0m[0;1;35mKLEE: WARNING ONCE: calling __user_main with extra arguments.
[0mKLEE: ctrl-c detected, requesting interpreter to halt.
KLEE: ctrl-c detected, requesting interpreter to halt.
KLEE: halting execution, dumping remaining states
[0m[0;1;32m
KLEE: done: total instructions = 14658
KLEE: done: completed paths = 22
KLEE: done: partially completed paths = 5
KLEE: done: generated tests = 27
[0m
```
 
Since no errors were found the verified code was presented in the verified.c file:

```c
int is_prime(int n) {
    if (n <= 1) return 0; // 0 and 1 are not prime numbers
    if (n <= 3) return 1; // 2 and 3 are prime numbers
    
    // This is checked so that we can skip middle five numbers in below loop
    if (n % 2 == 0 || n % 3 == 0) return 0;
    
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return 0;
    }
    return 1;
}
```

## Contributing
Contributions to this project are welcome. Please follow the standard GitHub pull request process to propose changes.


